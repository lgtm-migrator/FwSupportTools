using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

// Program to collect tests written in the unit++ framework, writing the
// constructor for each test suite.  This requires that all the tests be
// written in header (.h) files.  This program is invoked like this:
//
//     CollectCppUnitTests module testThis.h TestThat.h Collection.cpp
//
// The output is always written to Collection.cpp
//
// This does require a different approach to writing and organizing tests
// than the author of unit++ envisioned, one closer to the approach taken by
// the author of cxxtest.

namespace CollectCppUnitTests
{
	class Program
	{
		static void Main(string[] args)
		{
			var output = args[args.Length - 1];
			var writer = new StreamWriter(output);
			string module = args[0];
			var paths = args.Skip(1).Take(args.Length - 2).ToArray(); // inputs are all but the first and last arg.
			foreach (var path in paths)
			{
				writer.WriteLine("// AUTOMATICALLY GENERATED BY CollectCppUnitTests");

				// Include the input header file. Assume it is in a folder that the make knows to include,
				// so just include it by filename.
				writer.WriteLine("#include \"" + Path.GetFileName(path) + "\"");

				var reNamespace = new Regex("^[ \t]*namespace[ \t]+([a-zA-Z0-9_]*)[ \t]*({?)");
				// a class is a test class if it inherits from unitpp::suite.
				var reTestClass = new Regex("^[ \t]*class[ \t]+([a-zA-Z0-9_]+)[ \t]+:.*unitpp::suite");
				// a test is a method with void return type and no arguments.
				// The pattern for the argument is an inexact way of saying it should not have arguments
				// except optionally "void" (+/- white space).
				var reTest = new Regex("^[ \t]*void[ \t]+test([a-zA-Z0-9_]+)[ \t]*\\([void \t]*\\)");

				bool fOpenNamespace = false;
				bool fOpenClass = false;
				string namespaceName = "";
				string className = ""; // name the user calls the test class, with the leading Test removed.
				string testClassName = ""; // name of the class itself, as used by the compiler.

				var reader = new StreamReader(path);
				int lineNo = 0;
				while (!reader.EndOfStream)
				{
					var line = reader.ReadLine();
					if (line == null)
						break;
					lineNo++;
					// for each namespace in the .h, we need one in the output, unless it is not changing anything.
					var match = reNamespace.Match(line);
					if (match.Success)
					{
						if (fOpenClass)
						{
							fOpenClass = false;
							writer.WriteLine("\t}");
						}
						if (fOpenNamespace)
						{
							if (namespaceName == match.Groups[1].Value)
								continue; // ignore the new declaration, doesn't change anything.
							writer.WriteLine("}"); // close previous namespace.
						}
						writer.WriteLine(line);
						if (match.Groups[2].Value != "{") // if the opening brace wasn't part of the line, add one.
							writer.WriteLine("{");
						fOpenNamespace = true;
						namespaceName = match.Groups[1].Value;
						continue;
					}
					// Collect the test suite class, and write the first part of the constructor.
					// If the test suite class begins with Test (eg, TestMyClass), the name used
					// to invoke the suite will be minus the leading "Test" (eg, MyClass).  This
					// doesn't work too well if the test suite class is merely Test!
					match = reTestClass.Match(line);
					if (match.Success)
					{
						if (fOpenClass)
							writer.WriteLine("\t}");
						className = match.Groups[1].Value;
						testClassName = className;
						if (className.StartsWith("Test"))
							className = className.Substring("Test".Length);
						writer.WriteLine("\nstatic {0} * g_p{0} = new {0};\n", testClassName);
						writer.WriteLine("\t{0}::{0}()\n\t\t: suite(\"SIL.FieldWorks.{1}.{2}\")", testClassName, module,
							className);
						writer.WriteLine("\t{");
						writer.WriteLine("\t\tsuite::main().add(\"{0}\", this);", className);
						fOpenClass = true;
						continue;
					}

					// Collect an individual test, and add it to the suite's constructor.
					// If the test names begins with test (eg, testMyMethod), the name used to
					// invoke the individual test will be minus the leading "test" (eg, MyMethod).
					// This doesn't work too well if the test method name is merely test!
					match = reTest.Match(line);
					if (match.Success)
					{
						string testName = match.Groups[1].Value;
						string testFuncName = "test" + testName;
						writer.WriteLine("\t\tadd(\"{0}\",", testName);
						writer.WriteLine("\t\t\tunitpp::testcase(this, \"{0}.{1}\",", className, testName);
						writer.WriteLine("\t\t\t\t&{0}::{1}, \"{2}\", {3}));", testClassName, testFuncName,
							Path.GetFileName(path), lineNo);
					}
				}
				reader.Close();
				// Finish off any open constructor or namespace

				if (fOpenClass)
					writer.WriteLine("\t}");
				if (fOpenNamespace)
					writer.WriteLine("}");
			}
			writer.Close();
		}
	}
}
